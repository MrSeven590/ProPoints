# ProPoints 工分管理系统 - 技术方案总结

> 基于 Codex（后端架构）+ Gemini（前端架构）的综合方案
> 生成日期：2026-01-24

---

## 一、核心业务规则回顾

### 1.1 五环节工序流程
```
安曲 → 一次翻曲(7-9天) → 二次翻曲(6-8天) → 拆曲(40天) → 堆曲
```

### 1.2 工分计算公式
```
发酵仓总工分 = floor1(曲坯数量/20 × 系数)
floor1(x) = Math.floor(x * 10) / 10  // 向下取1位小数

系数表（可配置）：
- 安曲：1.1
- 一次翻曲：1.25
- 二次翻曲：0.9
- 拆曲：1.12
- 堆曲：0.29

安曲晾堂部分（按每日安曲总曲坯数）：
- 麦料参数人员：0.85
- 守机：0.8
- 下曲：0.8
- 微机：0.7（轮次轮换）
```

### 1.3 工分分配逻辑（核心难点）
- 拉车/打杂人员从多间发酵仓按曲坯数量比例抽取工分
- 发酵仓内人员分配剩余工分
- 校验：所有人员工分之和 = 发酵仓总工分

### 1.4 考核系统
- 违反工艺操作扣分
- 记录：考核原因、考核人员、被考核人员、考核分数

---

## 二、数据架构设计（Codex方案）

### 2.1 核心四表模型

#### StageSession（工序会话）
某天某工序的一次录入单
```
字段：
- id, session_date, stage_type（安曲/翻曲/拆曲/堆曲）
- round_id（轮次归属）
- coef_set_id（系数版本，防止历史数据漂移）
- status（draft/published/locked）
```

#### StageBin（发酵仓明细）
记录该会话涉及的发酵仓、曲坯数、总工分
```
字段：
- id, stage_session_id, bin_id
- koji_count（曲坯数量）
- bin_total_points（发酵仓总工分，存储计算结果）
```

#### Assignment（工分分配行）
记录人员/岗位的工分分配
```
字段：
- id, stage_session_id, stage_bin_id（nullable）
- person_id, person_name_raw（支持临时工）
- role_code（仓内主作业/拉车/打杂/晾堂岗位）
- position_index（站位顺序，用于追责）
- points（工分）
```

#### AssignmentSource（工分来源）
🔑 核心创新：记录跨仓抽取的工分来源
```
字段：
- id, assignment_id, stage_bin_id
- source_points（从该仓抽取的工分）

约束：
同一assignment的source_points之和 = assignment.points
```

### 2.2 辅助表
- `person`：人员基础信息
- `ferment_bin`：发酵仓基础信息
- `round`：轮次管理
- `coef_set` + `coef_item`：系数版本化管理
- `penalty`：考核扣分记录

### 2.3 存储方案
- **技术选型**：SQLite（强烈推荐）
- **理由**：支持复杂查询、事务、数据完整性约束
- **离线优先**：统一字段 `id + updated_at + deleted_at + version`
- **状态机**：`draft → published → locked`（锁定后不可直接修改）

---

## 三、业务逻辑架构（Codex方案）

### 3.1 工分计算引擎（纯函数）
```typescript
// 发酵仓总工分
function calcBinTotalPoints(kojiCount: number, coef: number): number {
    return floor1((kojiCount / 20) * coef)
}

// 向下取1位小数
function floor1(x: number): number {
    return Math.floor(x * 10) / 10
}
```

### 3.2 跨仓比例抽取算法
```
输入：
- bins[]：发酵仓列表，每仓曲坯数 k[i]
- P：跨仓岗位目标工分（如拉车10分）

步骤：
1. 计算原始份额：raw[i] = P × k[i] / sum(k)
2. 向下取1位小数：share[i] = floor1(raw[i])
3. 处理舍入残差：rem = P - sum(share)
4. 按小数余量从大到小分配0.1，直到rem用完
5. 生成1条Assignment + 多条AssignmentSource

输出：
- Assignment(points=P)
- AssignmentSource[](stage_bin_id, source_points)
```

### 3.3 数据校验规则
- **总账平衡**：sum(发酵仓总工分) = sum(人员工分)
- **仓内平衡**：发酵仓总工分 = 仓内人员工分 + 从该仓抽取的工分
- **来源完整性**：跨仓岗位工分 = sum(AssignmentSource)
- **站位完整性**：仓内人员必须填position_index，且同仓不重复

---

## 四、UI/UX设计（Gemini方案）

### 4.1 页面架构
```
底部导航：工作台 | 统计 | 我的

核心页面：
/pages
  /dashboard          # 工作台：今日任务、快速入口
  /production
    anqu-entry.uvue   # 安曲录入（双仓复杂模式）
    daily-entry.uvue  # 通用录入（其他环节）
    assessment.uvue   # 考核录入
  /stats
    person-stats.uvue # 人员查分
    room-trace.uvue   # 发酵仓追溯
  /admin
    settings.uvue     # 设置、Excel导出
```

### 4.2 安曲录入页面设计（核心交互）

#### 布局结构
1. **顶部**：日期、班组
2. **中部**：双仓数据卡（颜色区分：A仓淡蓝、B仓淡橙）
   - 仓号、曲坯数量
   - 4个圆形头像占位符（代表站位顺序）
3. **下部**：工分分配器
   - 总分池展示
   - 拉车工分输入
   - 工分流向可视化
   - 余分分配列表（支持一键均分）
4. **底部**：吸底校验栏（实时显示平衡状态）

#### 工分流向可视化
```
[A仓池55.0] --(5.6)--> [拉车池10.0] <--(4.4)-- [B仓池44.0]
```

### 4.3 交互优化

#### 自定义数字键盘
- 大按钮设计（适合现场嘈杂环境）
- 快捷键：Next（跳转）、+0.1/-0.1（微调）
- 占据屏幕下1/3，不遮挡内容

#### 一键均分功能
- 自动计算剩余工分并平均分配
- 支持手动微调

#### 实时校验
- 绿色=平衡可提交
- 红色=失衡禁用，提示具体差额

### 4.4 状态管理（UTS Singleton）
```typescript
class AnQuStore {
    state = reactive({
        roomA: { brickCount: 0, baseScore: 0, workers: [] },
        roomB: { brickCount: 0, baseScore: 0, workers: [] },
        cartScore: 0
    })

    // 计算拉车分摊
    readonly cartDeduction = computed(() => {
        // 调用Codex的跨仓抽取算法
    })

    // 校验逻辑
    readonly validationStatus = computed(() => {
        // 调用Codex的校验规则
    })

    // 一键均分
    distributeEvenly() { ... }
}
```

### 4.5 可复用组件（Easycom规范）
- `biz-worker-selector`：人员选择器（智能排序、常用置顶）
- `biz-score-input`：工分输入（自定义键盘、步进微调）
- `biz-process-stepper`：流程步骤指示器
- `chart-bar-stack`：轻量级堆叠柱状图

---

## 五、Excel导出方案

### 5.1 导出格式

#### Sheet1：人员×日期矩阵
```
       | 2026-01-20 | 2026-01-21 | ... | 合计
张三   |    15.2    |    18.5    | ... | 156.8
李四   |    12.8    |    16.2    | ... | 142.3
```

#### Sheet2：明细追溯
```
日期 | 工序 | 发酵仓 | 曲坯数 | 仓总分 | 人员 | 岗位 | 站位 | 工分 | 来源
```

### 5.2 技术实现
- **MVP优先**：导出CSV（UTF-8 BOM），Excel可直接打开
- **增强**：后续评估XLSX库支持情况

---

## 六、推荐的项目架构

```
/ProPoints
├── /database
│   ├── schema.sql          # SQLite建表脚本
│   ├── migrations/         # 数据迁移脚本
│   └── repository.uts      # 数据访问层
├── /domain
│   ├── /models             # 实体类型定义
│   ├── /services
│   │   ├── ScoreCalculator.uts    # 工分计算引擎
│   │   ├── ScoreAllocator.uts     # 跨仓抽取算法
│   │   └── Validator.uts          # 校验规则
│   └── /stores
│       └── AnQuStore.uts          # 状态管理
├── /components
│   ├── biz-worker-selector.uvue
│   ├── biz-score-input.uvue
│   └── biz-score-flow-chart.uvue  # 工分流向图
└── /pages
    ├── /dashboard
    ├── /production
    └── /stats
```

---

## 七、开发优先级建议

### Phase 1：基础设施（1-2天）
1. SQLite建表脚本
2. 人员/班组/发酵仓 CRUD
3. Repository层封装

### Phase 2：核心算法（2-3天）
4. 工分计算引擎（ScoreCalculator）
5. 跨仓抽取算法（ScoreAllocator）
6. 单元测试验证

### Phase 3：UI原型（3-4天）
7. 安曲录入页面（分段式卡片）
8. 工分流向可视化组件
9. 自定义数字键盘

### Phase 4：状态管理与集成（2-3天）
10. AnQuStore实现
11. UI与业务逻辑集成
12. 实时校验功能

### Phase 5：完善与测试（2-3天）
13. 其他环节录入（复用组件）
14. 考核系统
15. Excel导出（CSV）

**预计总工期**：10-15天完成MVP

---

## 八、技术风险点与应对

### 8.1 小数舍入导致对账不平
- **风险**：不同计算路径可能产生舍入误差
- **应对**：统一使用`floor1 + 残差分配`策略，提交时强校验

### 8.2 历史数据漂移
- **风险**：事后修改系数导致历史报表变动
- **应对**：系数版本化（coef_set_id），单据固化系数版本

### 8.3 站位追责
- **风险**：录入顺序混乱导致追责困难
- **应对**：强制position_index，UI可视化调整顺序

### 8.4 未来同步冲突
- **风险**：多人编辑同一单据产生冲突
- **应对**：状态机设计（locked后不可改），后续加更正单机制

---

## 九、关键决策点（需要您确认）

### 9.1 数据存储
- ✅ **推荐**：SQLite（支持复杂查询）
- ⚠️ 备选：uni-storage（仅适合简单KV存储）

### 9.2 Excel导出
- ✅ **MVP**：CSV格式（兼容性好，实现简单）
- 🔄 **增强**：XLSX格式（需评估库支持）

### 9.3 系数管理
- ✅ **推荐**：版本化管理（防止历史数据漂移）
- ⚠️ 备选：直接修改（风险高，不推荐）

### 9.4 工分精度
- ✅ **确定**：向下取1位小数（floor1）
- ✅ **残差处理**：按小数余量分配0.1

---

## 十一、后续扩展预留

### 11.1 多人协同
- 数据模型已预留：`updated_at + version`
- 状态机已设计：`draft → published → locked`
- 冲突策略：locked后不可改，走更正单

### 11.2 OCR识别
- 第一阶段手动录入
- 后续集成OCR服务识别排班表

### 11.3 云端同步
- 数据结构已支持增量同步
- 离线优先架构（offline-first）

---

## 十、技能自动打分功能（新增）

> 基于 Codex（算法设计）+ Gemini（UI交互）的协作方案

### 10.1 功能概述

**核心理念**：从"强制约束"到"建议辅助"
- ✅ 算法提供基于技能系数的建议分配
- ✅ 管理人员拥有最终决策权
- ✅ 不拒绝任何微调操作
- ✅ 记录建议值vs实际值，支持审计

**核心场景**：
- 拉车/打杂工分手动确定后，仓内人员按技能能力表自动分配
- 系统提供建议值，管理人员可自由调整
- 支持微调+自动平衡（调整一人，其他人联动）
- 显示偏离度，但不阻止提交

**设计原则**：
- 发酵仓总工分不变
- 微调时按技能系数自动平衡
- 提示偏离，不强制约束

### 10.2 数据模型扩展（Codex方案）

#### 技能系数表（版本化管理）

**skill_coeff_set（技能系数版本集）**：
```
字段：
- id, team_id（班组）
- version（版本号）
- effective_from, effective_to（生效/失效时间）
- created_by, created_at
- remark（调整原因说明）
```

**skill_coeff_item（技能系数明细）**：
```
字段：
- id, set_id（FK -> skill_coeff_set.id）
- person_id
- coeff（技能系数，如1.2）
- created_at
```

**历史复现机制**：
- `score_session`记录使用的技能版本ID（`skill_set_id`）
- `score_detail`冗余保存当时的系数快照（`coeff_snapshot`）
- 防止系数修改导致历史数据漂移

**关键原则**：
- ✅ 永远"新增版本"，不修改旧版本
- ✅ 旧版本填写失效时间（`effective_to`）

#### 建议值vs实际值（核心扩展）

**score_detail表扩展**：
```
字段：
- auto_suggested_units（算法建议值，0.1分整数单位）
- final_units（管理人员最终值，0.1分整数单位）
- deviation_units（偏离量 = final - suggested）
- is_manual（是否人工编辑）
- last_modified_by, last_modified_at
```

**score_adjust_log表（审计）**：
```
字段：
- session_id, operator_id, person_id
- before_units, after_units, delta_units
- balance_strategy（平衡策略，如add_by_skill）
- balanced_changes（JSON：联动变化记录）
- created_at
```

**用途**：
- 统计分析：哪些人经常偏离建议值
- 审计追溯：管理人员的调整依据
- 优化算法：根据历史偏离调整系数

### 10.3 自动粗打分算法（Codex方案）

#### 核心思路：最大余数法

**简化算法**（代替复杂的DP）：
- 按技能系数比例分配
- 用"最大余数法"保证总和精确
- O(n log n)复杂度，强可解释性

#### 计算步骤

```
1. 整数化：total × 10 → T（整数单位）
2. 比例分配：raw_i = T × w_i / sum(w)
3. 取整下界：base_i = floor(raw_i)
4. 计算余数：rem_i = raw_i - base_i
5. 最大余数补齐：
   - 按rem_i从大到小排序
   - 前R个各+1单位（R = T - sum(base_i)）
   - 保证sum(units_i) = T
```

**示例**：
```
总分49.4分，4人，技能系数[1.2, 1.0, 0.9, 0.8]
T = 494单位
比例分配：[152.8, 127.4, 114.6, 99.2]
取整下界：[152, 127, 114, 99] = 492
余数：[0.8, 0.4, 0.6, 0.2]
排序：0.8, 0.6, 0.4, 0.2
前2个+1：[153, 127, 115, 99] = 494 ✓
结果：[15.3, 12.7, 11.5, 9.9]
```

**算法特点**：
- ✅ 简单直观，易于理解
- ✅ 保证总和精确匹配
- ✅ 不再有差距约束

### 10.4 微调平衡算法（Codex方案）

#### 核心原则：永不拒绝微调

**设计理念**：
- ✅ 接受任何微调操作
- ✅ 自动平衡其他人工分
- ✅ 按技能系数分摊差额

#### 增量分摊策略

**管理人员调整某人 → 计算差额delta**：

**减分场景**（delta < 0）：
- 差额分配给其他人
- 权重：w_i（技能高的优先获得补偿）
- 示例：王五减0.2 → 张三（技能最高）加0.2

**加分场景**（delta > 0）：
- 从其他人扣除差额
- 权重：(w_max - w_i)（技能低的优先扣除）
- 示例：张三加0.5 → 从赵六（技能最低）扣0.5

#### 边界处理

**方案1（推荐）**：
- 下限0分，扣不完记入"调节项"
- 提示："当前最终值合计已超出总分"

**方案2**：
- 允许负数，UI高亮+审计记录
- 适用于编辑阶段，不适用于最终结算

#### 可选模式

**locked集合模式**：
- 维护手动指定的人（locked）
- 其余人按技能系数重新分配（unlocked）
- 更符合"按技能优先"原则

### 10.5 UI交互设计（Gemini方案）

#### 核心理念：从"管控"到"辅助"

**设计原则**：
- ✅ 赋予管理人员"知情后的决策权"
- ✅ 提示偏离，不阻止操作
- ✅ 效率优先，减少打断

#### 智能输入框（biz-smart-score-input）

**默认状态**（实际值=建议值）：
- 黑色大号数字
- 白色背景，干净无冗余

**偏离状态**（实际值≠建议值）：
- 数字变深蓝色（人工干预标识）
- 右下角显示：`建议14.2` + `+0.3`（橙色）
- 一眼看到当前值和偏离量

#### 偏离提示设计

**颜色编码**（不再用红色"错误"）：
- 微小偏离(<0.2)：灰色（正常微调）
- 显著偏离(≥0.2)：橙色（提示注意）
- 巨大偏离(≥1.0)：紫色加粗+边框微光

**提示方式**：
- Toast或顶部通知条
- 示例：`"当前分配偏离建议方案+1.2分"`
- 数秒后自动消失

#### 双层标尺设计

**从"执法者"到"数据分析师"**：
- 灰色细线：算法建议的范围（Shadow Bar）
- 蓝色实线：当前实际的范围（Active Bar）

**信息传达**：
- 蓝线覆盖灰线 → 调整后与算法一致
- 蓝线超出灰线 → 分差被拉大了
- 中性文案：`差值: 0.8`（不再是❌）

### 10.6 组件复用策略（Gemini方案）

#### 核心组件：智能输入框

**biz-smart-score-input**（新增）：
- **默认状态**：黑色数字，白色背景
- **偏离状态**：
  - 数字变深蓝色（人工干预标识）
  - 右下角显示建议值和偏离量
  - 颜色编码：灰色(<0.2) / 橙色(≥0.2) / 紫色(≥1.0)
- **交互功能**：
  - 点击显示自定义数字键盘
  - 支持步进器微调（±0.1）
  - 一键恢复建议值（Undo图标）

#### 升级现有组件

**biz-score-input**保持原有功能：
- 用于手动录入模式
- 支持自定义键盘
- 支持快捷键（Next、±0.1）

#### 新增专用组件

**biz-range-ruler**（双层标尺）：
- **Shadow Bar**：灰色细线，标记算法建议的分差范围
- **Active Bar**：蓝色实线，标记当前实际的分差范围
- **中性提示**：显示`差值: 0.8`，不再使用红色警告
- **信息图标**：点击显示"当前分差较大，建议复核"

**biz-star-coefficient**（星级系数器）：
- 5星=1.2, 4星=1.1, 3星=1.0, 2星=0.9, 1星=0.8
- 点击星星直接切换系数
- 保留数字输入框支持非标准系数（如1.15）

**biz-allocation-preview**（分配预览条）：
- 堆叠柱状图，可视化"蛋糕怎么切"
- 不同颜色块代表不同人员
- 实时更新，支持动画过渡

### 10.7 技术风险点与应对

**建议值被长期忽略**：
- ⚠️ 风险：管理人员习惯性偏离建议，导致技能系数失去意义
- ✅ 应对：定期生成"偏离分析报告"，统计哪些人员经常被高估/低估
- ✅ 应对：提供"系数校准建议"，根据历史偏离调整技能系数

**审计追溯复杂度**：
- ⚠️ 风险：记录建议值+实际值+调整日志，数据量增加
- ✅ 应对：设计高效的审计查询索引
- ✅ 应对：提供可视化的"调整热力图"，快速定位异常

**算法可解释性不足**：
- ⚠️ 风险：管理人员不理解"为什么建议这个值"
- ✅ 应对：UI显示计算公式（总分×系数÷系数和）
- ✅ 应对：提供"模拟器"功能，调整系数实时预览分配结果

**边界处理（扣分到负数）**：
- ⚠️ 风险：管理人员给某人加分过多，导致其他人被扣成负数
- ✅ 应对：方案1（推荐）：下限0分，扣不完记入"调节项"并提示
- ✅ 应对：方案2：允许负数但高亮警告，仅用于编辑阶段

**算法性能**：
- ✅ 最大余数法复杂度O(n log n)，4-10人场景毫秒级响应
- ✅ 增量平衡算法同样O(n log n)，实时微调无延迟

---

## 十二、需要细化的部分（待讨论）

请告诉我您希望细化以下哪些部分：

1. **SQLite建表脚本**：完整的DDL语句（含技能系数表）
2. **核心算法代码**：ScoreCalculator/ScoreAllocator的UTS实现
3. **技能自动打分算法**：DP算法的完整实现代码
4. **UI组件设计**：具体的uvue组件代码
5. **范围标尺组件**：biz-range-ruler的实现
6. **状态管理实现**：AnQuStore的完整代码（含自动打分逻辑）
7. **数据校验规则**：详细的校验逻辑
8. **Excel导出实现**：CSV生成的具体代码
9. **项目目录结构**：完整的文件组织方式
10. **开发流程细节**：每个阶段的具体任务拆解（含技能打分功能）

---

**方案制定者**：Claude Sonnet 4.5 + Codex + Gemini
**方案版本**：v2.0（技能打分从"约束模式"升级为"建议模式"）
**最后更新**：2026-02-01
